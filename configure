#!/bin/sh
#
# BashBuild v0.1.3 "It's Alive"
#
# BashBuild is a minimal build system implemented entirely in the configure script.
#  Project setup is performed by modifying the variables at the top of the script.
#  Subprojects are handled by configure scripts in subdirectories, called recursively.
#
# BashBuild is made available under the GPL, BSD, and MIT licenses.
#  Hopefully one of those will suffice.
#

# --- User Variables Start Here --- #

PROJECT="project-name"  # The name of the project being configured.
VERSION="0.0.0"         # The version of the project.
SOURCES="srcA.c srcB.c" # The source files to be compiler
LIBRARIES="libA libB"   # The libraries to be linked against
OUTPUT="output-type"    # The type of binary to be output

SUBPROJECTS="subA subB" # The names of subdirectories holding subprojects

LIBDIRS="/path/to/lib"  # The paths to extra library directories
INCDIRS="/path/to/inc"  # The paths to extra include directories

PREFIX="/usr/local"     # The default prefix for installations
CCFLAGS="-Wall -g"      # Additional compiler flags
LDFLAGS=""              # Additional linker flags

# --- User Variables End Here --- #

function main () {
    detectCompiler
    detectPaths
    parseArguments $@
    calcFilename

    subprojectsConfigure

    startOutput

    # Print header
    writeLine "# Makfile for project: $PROJECT"
    writeLine "#   Generated by BashBuild v0.1.3"
    writeLine "#   On $(date)"

    writeVariables
    writeBuildRules

    stopOutput
}

# --- Autodetection Functions --- #
function detectCompiler () {
    # Autodetect compiler paths
    C_COMPILER=""
    if [ -z "$C_COMPILER" ]; then C_COMPILER=`which gcc`; fi;
    if [ -z "$C_COMPILER" ]; then C_COMPILER=`which cc`; fi;

    CPP_COMPILER=""
    if [ -z "$CPP_COMPILER" ]; then CPP_COMPILER=`which g++`; fi;
    if [ -z "$CPP_COMPILER" ]; then CPP_COMPILER=`which c++`; fi;
}

function detectPaths () {
    # Autodetect source file main directory
    PROJDIR="$(readlink -f $(dirname $0))"
    BUILDDIR=`pwd`
}


# --- Parse the command-line arguments to ./configure --- #
function parseArguments () {
    OPTLIST=`getopt -n './configure' -o 'p:c:' -l 'prefix:' -- $@`
    set -- $OPTLIST
    while [[ ! "$1" == '--' ]]; do
        case "$1" in
            -p | --prefix   ) shift; PREFIX="$1"; shift;;
            -c | --compiler ) shift; C_COMPILER="$1"; shift;;
            *               ) echo "./configure [-h,--help] [-p,--prefix=install-prefix] [-c,--compiler=c-compiler]" >&2; exit;;
        esac
    done
}


# --- Calculate the filename for the resulting binary --- #
function calcFilename () {
    # Determine output file name
    BINARY="$PROJECT"
    if [ "$OUTPUT" == "shared" ]; then BINARY="lib$PROJECT.so"; fi;
    if [ "$OUTPUT" == "static" ]; then BINARY="lib$PROJECT.a"; fi;
}


# --- Recursively run the subproject configure scripts --- #
function subprojectsConfigure () {
    for dir in $SUBPROJECTS; do
	mkdir -p "$dir"
	cd "$dir"
	sh $PROJDIR/$dir/configure -p "$PREFIX" -c "C_COMPILER"
	cd "$BUILDDIR"
	if [ ! -f "$BUILDDIR/$dir/Makefile" ]; then echo "Error: Unable to configure $dir">&2; exit; fi;
    done
}

# --- Various output functions --- #
function writeVariables () {
    # Print some important variables
    writeLine "PROJECT=$PROJECT"
    writeLine "VERSION=$VERSION"
    writeLine "LFLAGS=$LDFLAGS \$(foreach i,$LIBDIRS,-L\$(i)) \$(foreach i,$LIBRARIES,-l\$(i))"
    writeLine "CFLAGS=$CCFLAGS \$(foreach i,$INCDIRS,-I\$(i))"
    writeLine "SUBPROJECTS=$SUBPROJECTS"
    writeLine "SOURCES=\$(foreach i,$SOURCES,$PROJDIR/\$(i))"
    writeLine "SOURCES_TMP=\$(foreach i,$SOURCES,$BUILDDIR/\$(i))"
    writeLine "OBJECTS_BLD=\$(SOURCES_TMP:.c=.o)"
}

function writeBuildRules () {
    writeBuildAll
    writeBuildBinary
    writeBuildObjects
    writeBuildSubprojects
    writeBuildExtra
}

function writeBuildAll () {
    writeLine "all: \$(SOURCES_PRJ) $BINARY"
}

function writeBuildBinary () {
    writeLine "$BINARY: \$(OBJECTS_BLD) \$(SUBPROJECTS)"
    writeLine "ifdef SOURCES"
    case "$OUTPUT" in
	shared) writeLine "	$C_COMPILER -shared \$(OBJECTS_BLD) \$(LFLAGS) -o $BINARY";;
	static) writeLine "	ar rcs $BINARY \$(OBJECTS_BLD)";;
	*     ) writeLine "	$C_COMPILER \$(OBJECTS_BLD) \$(LFLAGS) -o $BINARY";;
    esac
    writeLine "endif"
}

function writeBuildObjects () {
    writeLine  "$BUILDDIR/%.o: $PROJDIR/%.c"
    writeLine  "	$C_COMPILER -c \$(CFLAGS) -fPIC \$< -o \$@"
}

function writeBuildSubprojects () {
    writeLine  "\$(SUBPROJECTS):"
    writeLine  "	make -C \$@"
}

function writeBuildExtra () {
    # The install rule
    writeLine  "install:"
    writeLine  "	@ for i in \$(SUBPROJECTS); do make -C \$\${i} install; done"
    case "$OUTPUT" in
	shared | static) writeLine "	install $BINARY $PREFIX/lib";;
	*              ) writeLine "	install $BINARY $PREFIX/bin";;
    esac

    writeLine  "tidy:"
    writeLine  "	@ for i in \$(SUBPROJECTS); do make -C \$\${i} tidy; done"
    writeLine  "	rm -f \$(OBJECTS_BLD)"

    writeLine  "clean:"
    writeLine  "	@ for i in \$(SUBPROJECTS); do make -C \$\${i} clean; done"
    writeLine  "	rm -f \$(OBJECTS_BLD) $BINARY"

    writeLine  "distclean:"
    writeLine  "	@ for i in \$(SUBPROJECTS); do make -C \$\${i} distclean; done"
    writeLine  "	rm -f \$(OBJECTS_BLD) $BINARY Makefile"

    writeLine  ".PHONY: install tidy clean distclean \$(SUBPROJECTS)"
}

# --- Output Functions --- #
function startOutput () {
    TMPFILE="Makefile.partial"
    rm -f Makefile "$TMPFILE"
}

function writeLine () {
    echo "$1" >> "$TMPFILE"
}

function stopOutput () {
    # Move the temporary makefile to the real one
    mv "$TMPFILE" Makefile
}

# Reconfigure ability
if [ "$1" == 'reconfigure' ]
then
    # Takes the variables from another script, and implants them into this one's code
    if [[ -z "$2" || ! -f "$2" ]]; then echo 'Usage: ./configure reconfigure <variable-file>'; exit; fi;

    STARTSTRING='# --- User Variables Start Here --- #'
    ENDSTRING='# --- User Variables End Here --- #'

    # Print lines up to (not including) STARTSTRING
    awk "BEGIN {p = 1}; /$STARTSTRING/ {p = 0}; p > 0 {print \$0}" `readlink -f $0`
    # Print lines between STARTSTRING and ENDSTRING, inclusive
    awk "BEGIN {p = 0}; /$STARTSTRING/ {p = 1}; /$ENDSTRING/ {p = 0; print \$0}; p > 0 {print \$0}" "$2"
    # Print lines after (not including) ENDSTRING
    awk "BEGIN {p = 0}; p > 0 {print \$0}; /$ENDSTRING/ {p = 1};" `readlink -f $0`
else
    main $@
fi

# BashBuild Copyright (c) 2009 Will Donnelly <will.donnelly@gmail.com>
